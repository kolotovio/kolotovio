## Обработка и использование объектов большой вложенности во VueJS

Частенько возникают ситуации, когда с бэкэнда прилетает примерно вот такой ответ с данными:

```
{
    "id": 1,
    "title": "Object Title",
    "children": [
        {
            "id": 1,
            "child_title": "Child Title 1",
            "img": {
                "id": 1,
                "path": "/storage/image1.webp"
            }
        },
        {
            "id": 1,
            "child_title": "Child Title 2",
            "img": {
                "id": 2,
                "path": "/storage/image2.webp"
            }
        },
        {
            "id": 1,
            "child_title": "Child Title 3",
            "img": {
                "id": 3,
                "path": "/storage/image3.webp"
            }
        },
    ]
}
```
И необходимо редактиовать объекты на всех уровнях вложенности, условно одновременно, а потом сохранить результат в БД или что-то в этом роде.

Собственно проблема в том, когда мы определяем эти (пришедшие) данные как реактивные, т.е. выводим их через computed, reactive или ref, то получиться динамически изменять только данные на 0 уровне вложенности объекта (значения полей id и title).

Для этого, можно воспользоваться Vuex - файл конфигурации хранилища - [store.js](./store.js). Так как весь обмен данными с бэкэндом во Vuex, то логично и все действия над объектом проводить там же за счет мутаций.

Пример с формой редактирования значений и взаимодействия с Vuex представлен в файле [app.vue](./app.vue)

#### Отслеживание изменений объекта с большой вложенностью

Еще одна, побочная проблема - определить изменился ли исходный (полученный) объект, и если да, то предложить пользователю сохранить изменения, либо выполнить какие-то другие действия автоматически.

Для этого во Vuex используем компонент библиотеки Lodash - cloneDeep. Можно конечно написать свой "велосипед" для клонирования, но зачем? Компонент прекрасно справляется со свей задачей и экономит время.

Добавляем дополнительное хранилище для клонированного объекта `objectFreezed`, а на этапе коммита `setObject` используем cloneDeep одновременно с заполнение стейта `object`.

Далее, что ты отслежить изменения добавим геттер `isModified`, в котором переводим стейты объектов `object` и `objectFreezed` в стоки за счет `JSON.stringify` и сравниваем их.